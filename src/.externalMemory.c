#include "externalMemory.h"

/*
 * This module manages the external memory used on the sparkbox.
 * 
 * How to use this module:
 * Call the initialization function to initialize the external memory
 * Call external_malloc() and external_free() to move the extMemPtr
 * acting as a stack pointer to keep track of the memory still available for use
 */

static volatile uint32_t extMemPtr = EXTERNAL_MEM_BASE;
NAND_HandleTypeDef hnand1;

// Initializes external memory. Modified from code generated by STM32CubeMX
void external_init(void)
{
	FSMC_NAND_PCC_TimingTypeDef ComSpaceTiming;
	FSMC_NAND_PCC_TimingTypeDef AttSpaceTiming;
	
	/** Perform the NAND1 memory initialization sequence */
	hnand1.Instance = FSMC_NAND_DEVICE;
	/* hnand1.Init */
	hnand1.Init.NandBank = FSMC_NAND_BANK3;
	hnand1.Init.Waitfeature = FSMC_NAND_PCC_WAIT_FEATURE_ENABLE;
	hnand1.Init.MemoryDataWidth = FSMC_NAND_PCC_MEM_BUS_WIDTH_16;
	hnand1.Init.EccComputation = FSMC_NAND_ECC_DISABLE;
	hnand1.Init.ECCPageSize = FSMC_NAND_ECC_PAGE_SIZE_256BYTE;
	hnand1.Init.TCLRSetupTime = 0;
	hnand1.Init.TARSetupTime = 0;
	/* hnand1.Config */
	hnand1.Config.PageSize = 1032;
	hnand1.Config.SpareAreaSize = 32;
	hnand1.Config.BlockSize = 68000;
	hnand1.Config.BlockNbr = 1024;
	hnand1.Config.PlaneNbr = 2;
	hnand1.Config.PlaneSize = 69024;
	hnand1.Config.ExtraCommandEnable = DISABLE;
	/* ComSpaceTiming */
	ComSpaceTiming.SetupTime = 3;
	ComSpaceTiming.WaitSetupTime = 3;
	ComSpaceTiming.HoldSetupTime = 4;
	ComSpaceTiming.HiZSetupTime = 3;
	/* AttSpaceTiming */
	AttSpaceTiming.SetupTime = 3;
	AttSpaceTiming.WaitSetupTime = 3;
	AttSpaceTiming.HoldSetupTime = 4;
	AttSpaceTiming.HiZSetupTime = 3;

	if (HAL_NAND_Init(&hnand1, &ComSpaceTiming, &AttSpaceTiming) != HAL_OK) {
		_Error_Handler(__FILE__, __LINE__);
	}	
}

/*
 * "Allocates" memory from the external memory bank
 * If there is not enough memory, will return NULL,
 * otherwise a pointer to allocated memory location.
 *
 * @args: 
 */
void *external_malloc(uint32_t sizeBytes);
{
	if (extMemPtr + sizeBytes + 4 > EXTERNAL_MEM_END) {
		// Not enough room for memory and size of memory
		// Return NULL to signify calling function
		return NULL;
	} else {
		// Enough memory is available, allocate it

		// Update the memory pointer
		extMemPtr += sizeBytes;
		
		// Return pointer to original memory location
		return (void*)(extMemPtr - sizeBytes);
	}
}

/*
 * "Frees" memory from the external memory bank
 * If the user attempts to "free" memory outside of the
 * valid address range, will only "free" all external memory
 */
void external_free(uint32_t sizeBytes)
{
	if (extMemPtr - sizeBytes < EXTERNAL_MEM_BASE) {
		// User attempted to free too much memory
		// Set pointer equal to the base memory address
		extMemPtr = EXTERNAL_MEM_BASE;
	} else {
		// Decrement external memory pointer by the size of bytes
		extMemPtr = extMemPtr - sizeBytes;
	}

	return;
}


void external_free_all(void)
{
	// Reset memory pointer to base address
	extMemPtr = EXTERNAL_MEM_BASE;
}
